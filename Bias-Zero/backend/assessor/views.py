from rest_framework import permissions, status
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework.response import Response
from rest_framework.views import APIView
from django.core.files.storage import default_storage
from langchain_groq import ChatGroq
from langchain_core.prompts import ChatPromptTemplate
from langchain.prompts import PromptTemplate
from dotenv import load_dotenv
from .models import QuestionAnswer
from .serializers import QuestionAnswerSerializer, PDFUploadSerializer, URLUploadSerializer
from models.pdfanalyser import qa_generator_pdf, qa_generator_url
import os
import uuid
import ast
import json

load_dotenv()


pdf = True
url = True
gen_ai = True

options = [pdf, url, gen_ai]

# Count the number of selected options
number_of_options = sum(options)

# Assign question distribution based on the number of selected options
if number_of_options == 1:
    questions_pdf, questions_url, questions_gen_ai = (40 if option else 0 for option in options)
elif number_of_options == 2:
    questions_pdf, questions_url, questions_gen_ai = (20 if option else 0 for option in options)
else:
    questions_pdf, questions_url, questions_gen_ai = 13, 13, 14

# print(questions_pdf)
# print(questions_url)
# print(questions_gen_ai)

def number_of_questions(no_questions):
    
    number_of_questions=no_questions
  
    # Calculate the base number of questions per level
    base_number = number_of_questions // 4

    # Calculate the remainder
    remainder = number_of_questions % 4

    # Create the list of questions per level, distributing the remainder
    number_of_questions_levelwise = [base_number + 1 if i < remainder else base_number for i in range(4)]
    
    return number_of_questions_levelwise
    

llamaparse_api_key = os.getenv('LLAMA_API_KEY')
groq_api_key = os.getenv("GROQ_API_KEY")


# set the job profile here
job_profile="Data Scientist"


#To store the questions and answers generated by different sources in three
# different dictionaries

result_dict_pdf={}
result_dict_url={}
result_dict_gen_ai={}
result_final={}

def extract_and_convert_to_dict(input_string):
    # Find the position of the first '{' and the last '}'
    start = input_string.find('{')
    end = input_string.rfind('}')
    
    if start == -1 or end == -1 or start >= end:
        raise ValueError("The input string does not contain valid JSON-like content.")
    
    # Extract the substring between the first '{' and the last '}'
    json_like_string = input_string[start:end+1]
    
    # Convert the extracted string to a dictionary
    result_dict = ast.literal_eval(json_like_string)
    
    return result_dict

def merge_with_unique_keys(input_dict, result_dict):
    for key, value in input_dict.items():
        # Generate a unique key using UUID
        unique_key = str(uuid.uuid4())
        # Add the key-value pair to the result dictionary
        result_dict[unique_key] = value

def merge_and_save_dicts(dict1, dict2, dict3, output_filename):
    # Merging the dictionaries, filtering out empty ones
    result_final = {**dict1, **dict2, **dict3}
    
    # Check if the final dictionary is empty
    if not result_final:
        print("All input dictionaries are empty. Nothing to save.")
        return
    
    # Saving the merged dictionary to a JSON file
    with open(output_filename, "w") as json_file:
        json.dump(result_final, json_file, indent=4)
    
    print(f"Merged dictionary saved to {output_filename}")
    
class QuestionAnswerAPIView(APIView):
    permission_classes = [permissions.AllowAny]
    parser_classes = [MultiPartParser, FormParser]

    def get(self, request, *args, **kwargs):
        qa = QuestionAnswer.objects.all()
        serializer = QuestionAnswerSerializer(qa, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

    def post(self, request):
        source = request.data.get('source')
        if source == 'file':
            return self.handle_file_upload(request)
        elif source == 'url':
            return self.handle_url_upload(request)
        else:
            return Response({'error': 'Invalid source type'}, status=status.HTTP_400_BAD_REQUEST)

    def handle_file_upload(self, request):
        serializer = PDFUploadSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        pdf_file = serializer.validated_data['pdf_file']
        
        try:    
            qg_obj = qa_generator_pdf()
            
            #Pass the path of PDF here
            parsed_data = qg_obj.load_or_parse_data(llamaparse_api_key,"data/Decision_tree.pdf")

            embed_model= qg_obj.create_vector_database(parsed_data)

            chat_model=qg_obj.chat_model(groq_api_key)

            retriever=qg_obj.vectorstore(embed_model)

            
            # Create the list of questions level-wise
            number_of_questions_levelwise = number_of_questions(questions_pdf)

            print(number_of_questions_levelwise)

            custom_prompt_template = """Use the following pieces of information to answer questions of the user.
            Context: {context}
            question: {question}
            Only return the helpful content and nothing else.
            """

            prompt=qg_obj.set_custom_prompt(custom_prompt_template)
                
                    
            query_template = f"""
            Generate {questions_pdf} technical interview questions and answers suitable for a 
            candidate applying for the following role :

            Please generate the specified number of questions exactly.

            **Job Profile:**

            {job_profile}
            Difficulty Distribution:
            - Easy: {number_of_questions_levelwise[0]} questions
            - Medium: {number_of_questions_levelwise[1]}questions
            - Hard: {number_of_questions_levelwise[2]} questions
            - Very Hard: {number_of_questions_levelwise[3]}questions
            
            first tell me the number of questions you are asked to create 
            for each difficult level. stock to those numbers only. 
            
            Formulate interview questions based on the provided content only,
            the specified difficulty levels, the responsibilities mentioned in the job 
            profile, and the listed requirements.

            Ensure that the exact specified number of questions are generated for each difficulty 
            level only. Do not set the numbers of questions generated for each difficulty
            level by yourself.

            Do not use reference of any table, example or any diagram in the provided content as
            the interviewee will not be provided with any material.

            Do not add questions and answers by yourself other than the provided content.

            Strictly use the provided content only.Do not generate questions
            on your own.
            
            Return the output as a Python dictionary where keys are the integer serial 
            number of the questions and answers, and values are Python dictionaries containing the 
            question, answer, and difficulty level. 
            Do not return anything other than the dictionary.
            
            The structure should be:
            {{
            "1": {{
                "question": "Example question",
                "answer": "Example answer",
                "difficulty": "Easy"
            }},
            "2": {{
                "question": "Example question",
                "answer": "Example answer",
                "difficulty": "Medium"
            }},
            ...
            }}
            """


            response=qg_obj.output_generator(chat_model,retriever,prompt,query_template)


            # print(type(response))

            # print(response)

            final_result=extract_and_convert_to_dict(response) 

            print(final_result.keys())

            merge_with_unique_keys(final_result,result_dict_pdf)

            for key, value in result_dict_pdf.items():
                print(str(key) + " ")
                print(value)
                print("\n")

            print("\n\n\n\n\n\n\n\n")
            return Response({'message': 'File uploaded and processed successfully!'}, status=status.HTTP_201_CREATED)
        
        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def handle_url_upload(self, request):
        serializer = URLUploadSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        url = serializer.validated_data['url']

        try:
            # Process the URL with qa_generator_url and save to your model here
                    url="https://www.ibm.com/topics/machine-learning"

                    qg_obj=qa_generator_url

                    number_of_questions_levelwise = number_of_questions(questions_url)

                    print(number_of_questions_levelwise)
                    print(job_profile)

                    prompt=ChatPromptTemplate.from_template ("""
                    Generate {questions_url} technical interview questions and answers suitable for a 
                    candidate applying for the following role :
                                                            
                    Please generate the specified number of questions exactly.

                    **Job Profile:**

                    {job_profile}
                    Difficulty Distribution:
                    - Easy: {easy} questions
                    - Medium: {medium} questions
                    - Hard: {hard} questions
                    - Very Hard: {veryhard} questions
                
                    Formulate interview questions based on the provided content {data} only,
                    the specified difficulty levels, the responsibilities mentioned in the job 
                    profile, and the listed requirements. 

                                
                    Do not use reference of any table, example, any diagram or any such information from the
                    content that is irrevelant to the interviewee from the provided content

                    Do not add questions and answers by yourself other than the provided content.

                    Return the output as a Python dictionary where keys are the integer serial 
                    number of the questions and answers, and values are Python dictionaries containing the 
                    question and answer. 
                    Do not return anything other then the dictionary. Do not add the tag of difficulty level
                    
                    Return the output as a Python dictionary where keys are the integer serial 
                    number of the questions and answers, and values are Python dictionaries containing the 
                    question, answer, and difficulty level. 
                    Do not return anything other than the dictionary.
                    
                    The structure should be:
                    {{
                    "1": {{
                        "question": "Example question",
                        "answer": "Example answer",
                        "difficulty": "Easy"
                    }},
                    "2": {{
                        "question": "Example question",
                        "answer": "Example answer",
                        "difficulty": "Medium"
                    }},
                    ...
                    }}
                    """)

                

                    qg_object=qa_generator_url(url,n_href=None,prompt_template=prompt)
                    response=qg_object.generate_questions(questions_url,number_of_questions_levelwise)

                    # print(response)
                
                    final_result=extract_and_convert_to_dict(response) 

                    print(final_result.keys())

                    merge_with_unique_keys(final_result,result_dict_url)

                    for key, value in result_dict_url.items():
                            print(f"{key}: {value}")
                            print("\n\n")

                    return Response({'message': 'URL processed successfully!'}, status=status.HTTP_201_CREATED)

        except Exception as e:
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# class FaceResultView(APIView):
#     def get(self, request, *args, **kwargs):
#         uploaded_images = UploadedImage.objects.all()
#         serializer = UploadedImageSerializer(uploaded_images, many=True)
#         return Response(serializer.data, status=status.HTTP_200_OK)
    
#     def post(self, request, *args, **kwargs):
#         serializer = ImageUploadSerializer(data=request.data)
#         if serializer.is_valid():
#             image1 = serializer.validated_data['image1']
#             image2 = serializer.validated_data['image2']
            
#             # known_image_path = os.path.join(settings.BASE_DIR, '/file/{images1}')

#             known_image_path = "/media/admsher/EXTERNAL/Gitrepo/DRF-project/backend/backend/post/known_person.jpg"
#             predictor_path = '/media/admsher/EXTERNAL/Gitrepo/DRF-project/backend/backend/post/shape_predictor_68_face_landmarks.dat'  

#             recognizer = FaceRecognizer(known_image_path, predictor_path)
#             recognizer.recognize_faces()
#             recognizer.release()
            
#             uploaded_image = UploadedImage(image=image1)
#             uploaded_image.save()

#             return Response({"message": "Images received"}, status=status.HTTP_201_CREATED)
#         return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
